{
  "name": "calculator",
  "description": "Performs basic arithmetic on two numbers.",
  "type": "tool",
  "backend": "openai",
  "tool_type": "function",
  "bindings": {
    "openai": {
      "parameters": {
        "type": "object",
        "properties": {
          "a": {
            "type": "number",
            "description": "The first operand"
          },
          "b": {
            "type": "number",
            "description": "The second operand"
          },
          "operation": {
            "type": "string",
            "enum": ["add", "subtract", "multiply", "divide"],
            "description": "The operation to perform"
          }
        },
        "required": ["a", "b", "operation"]
      },
      "function": "calculator"
    },
    "mcp": {
      "endpoint": "http://mcp.internal/api/calculate",
      "method": "POST",
      "headers": {
        "Authorization": "Bearer ${MCP_TOKEN}"
      },
      "payload_template": {
        "operand1": "${input.a}",
        "operand2": "${input.b}",
        "operator": "${input.operation}"
      },
      "response_path": "result"
    }
  },
source: "import re\n\ndef calculator_handler(input_str: str) -> float:\n    input_str = input_str.strip().lower()\n\n    # 1. Try symbolic math: e.g., \"7 * 3\", \"10/2\", \"7x3\"\n    symbol_pattern = r'^\\s*([-+]?\\d*\\.?\\d+)\\s*([x\\*/\\-\\+])\\s*([-+]?\\d*\\.?\\d+)\\s*$'\n    match = re.match(symbol_pattern, input_str)\n    if match:\n        a = float(match.group(1))\n        operator = match.group(2)\n        b = float(match.group(3))\n        return perform_operation(a, b, operator)\n\n    # 2. Try natural language patterns\n    nl_patterns = [\n        (r'add\\s+([-+]?\\d*\\.?\\d+)\\s+(and|to)\\s+([-+]?\\d*\\.?\\d+)', '+'),\n        (r'subtract\\s+([-+]?\\d*\\.?\\d+)\\s+from\\s+([-+]?\\d*\\.?\\d+)', '-'),\n        (r'multiply\\s+([-+]?\\d*\\.?\\d+)\\s+(and|by)\\s+([-+]?\\d*\\.?\\d+)', '*'),\n        (r'divide\\s+([-+]?\\d*\\.?\\d+)\\s+by\\s+([-+]?\\d*\\.?\\d+)', '/')\n    ]\n\n    for pattern, operator in nl_patterns:\n        match = re.search(pattern, input_str)\n        if match:\n            if operator == '-':\n                b = float(match.group(1))\n                a = float(match.group(2))\n            else:\n                a = float(match.group(1))\n                b = float(match.group(3))\n            return perform_operation(a, b, operator)\n\n    raise ValueError(f\"Could not parse input: '{input_str}'\")\n\n\ndef perform_operation(a: float, b: float, operator: str) -> float:\n    if operator in ['x', '*']:\n        return a * b\n    elif operator == '/':\n        return a / b if b != 0 else float('inf')\n    elif operator == '+':\n        return a + b\n    elif operator == '-':\n        return a - b\n    else:\n        raise ValueError(f\"Unsupported operation: {operator}\")"
}
